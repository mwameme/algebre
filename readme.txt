En algebre on peut définir plusieurs types d'objets. Ici sont définis les rationnels (p/q), les polynomes (a + bX + c X^2 +...), les matrices ({{a,b,c},{d,e,f},{g,h,i}}). Informatiquement on garde en mémoire les coefficients. Mathématiquement on calcule l'addition la multiplication et la division d'une manière bien définie. Ces objets peuvent se combiner : on peut définir un polynome à coefficients rationnels d'entiers. En C++ cela se traduit par le fait qu'on définit un polynome en fonction d'une autre classe, qui peut être quelconque, mais définie avant la compilation. Ce procédé s'appelle template, et on écrit la classe polynome<T>, où T est le type d'objet des coefficients. L'addition et la multiplication de polynome va maintenant utiliser l'addition et la multiplication du type T. On écrit le même algorithme ue fois pour toutes, dans la classe des polynomes, mais en foncion du type de T on utilisera des compilations différentes. Ce type T doit être connu avant l'utilisation du programme, avant la compilation (qui le transforme sous forme d'application .exe). Par exemple on peut considérer l'objet rationnel<polynome<rationnel<entier>>>, qui représente P/Q, où P et Q sont des polynomes à coefficients du type rationnel d'entiers. J'ai trouvé des librairies C++ pour des entiers de taille (possiblement) infinie, et idem des nombres réels à précision quelconque : ces librairies s'ajoutent très bien à mes objets algébriques. (j'ai juste modifié un tout petit peu ces librairies, pour ajouter certaines opérations).

les objets utilisés ici sont les polynomes; les rationnels; les matrices; et les polynomes à nombre de variable quelconque (modifiable après la compilation), codés de 3 manières différentes : en itératif, en récursif, et en stockant seulement les monomes non-nuls. Un monome est un polynome avec un seul coefficient, du type a* X^2 * Y^3 * ... (nombre fini de variables). Il y a aussi les anneaux quotients et les corps quotients (utilier pour les entiers et les polynomes). Il y a aussi une classe erreur<T> (où T est un type de nombre réel), qui garde trace des imprécisions cumulées au fil des opérations. Enfin une petite classe de complexes (pour n'avoir pas à modifier la librairie standard des complexes).

Pour les besoins, j'ai créé une fonction, qui à un objet (quelconque) retourne le 0 ou le 1 pour cette classe d'objets. Il y a aussi une fonction norme qui regarde seulement la somme (et le quotient, dans le cas rationnel) des valeurs absolues des coefficients. Il y a aussi une classe qui à chaque type, retourne des caractéristiques de ce type : y a-t-il un polynome à un moment, quel est le corps sur lequel ce type est défini (rationnel d'entier, corps quotient d'entier, ou nombre réel ou complexe), y a-t-il un rationnel à un moment (sauf à la fin), l'objet a-t-il une division exacte ou une division avec reste ou aucune division, les calculs sont-ils approchés (nombre réels) ou exactes (rationnels d'entiers ou corps quotient d'entiers).

En fonction du type T, quand on définit les objets, sont implémentables, ou non, ou de manières différentes, les différents algorithmes. Par exemple polynome<T> a une division avec reste si T a une division exacte, et alors on peut utiliser l'algorithme du PGCD pour simplifier les fractions rationnel<polynome<T>>. Pour un polynome à n variable, cet algorithme n'existe pas, mais dans le cas où P/Q = R, on peut trouver le R correcte ... 

Détails :
La diagonalisation : ici le but n'est pas d'écrire une diagonalisation de matrices à coefficients réels, mais d'écrire les vecteurs propres (pour chaque coordonnée) sous forme de polynome en lambda, où lambda est une valeur propre de la matrice, sans connaitre lambda. Notons P le polynome caractéristique de la matrice A. On cherche à obtenir A X = lambda X, où P(lambda) =0. On implémente donc les algorithmes de matrice habituels, en notant que si une coordonnée est un polynome U, en utilisant bezout on a UV + WP = 1, or P(lambda) = 0, donc on a U(lambda) * V(lambda) = 1. On ne travaille donc pas avec des rationnels de polynomes en lambda, mais avec un corps quotient de polynomes en lambda. Mais si U a une racine en commun avec P, alors on sépare P en deux parties : une partie qui annule tout le temps U, et une autre partie qui n'annule jamais U (et on peut donc trouver l'inverse de U, noté V).

si P et Q sont des polynomes à n variables, on ne peut pas simplifier P/Q. Mais en supposant P/Q =  R, on peut calculer R (ou trouver une erreur lorsque c'est impossible). On écrit R comme une somme de monomes, avec un coefficient (inconnu) x_i devant chacun. Q*R est donc un polynome qu'on peut calculer, en somme de scalaires fois les inconnus x_i, devant chaque monome. En écrivant P=Q*R, on a donc un système d'équations linéaires, et on utilise la classe des matrices pour les résoudre (ou trouver qu'il n'y a pas de solution). Cette opération est néanmoins coùteuse en temps. On part donc de P et Q, définit comme polynome_n<T>, et on utilise l'objet scalaire_vecteur<T> qui est soit un nombre (un scalaire), soit un vecteur (somme des scalaires fois des inconnus): on réécrit Q dans cette nouvelle classe (qui sont de type scalaires), et on écrit R aussi dans cette classe, on calcule Q*R qui est un polynome_n<scalaire_vecteur<T>>, et en écrivant R=Q*R on a un système d'équations linéaires, que l'on résout (dans matrice<T>).

Ont été aussi programmé des n_for : une boucle for incrémente une seule variable à la fois, avec des bornes de début et de fin, mais un n_for incrémente une liste de variables, avec une liste de bornes de fin. Dans le même style, il y a fact_for, qui parcourt toutes les permutations dans nombres entre 1 et n (ces même nombres, dans un ordre différent). Il y a encore un vecteur_n qui est un vecteur de plusieurs dimensions : il stocke x_{ijkl} (cas n=4), où i j k et l sont des entiers variant entre n_1,n_2,n_3 et n_4. Cela est utilise dans la définition des polynome_n_iteratif : P = Somme_{ijkl} x_{ijkl} X^i Y^j Z^k W^l ... Les polynomes en récursif contiennent soit un polynome de polynomes récurisfs, soit un scalaire (un nombre de type T). Les polynomes en sparse contiennent juste la liste des monomes ...

Pour utiliser ces objets, il ne faut jamais avoir une liste vide. En effet, si mon polynome à n variables disparait (la liste de polynome à n variables est vide), comment je peux savoir le nombre n ? Ce cas arrive dans polynome<polynome_n> où la liste du polynome est vide ... Idem, si on travaille sur un corps quotient, alors comment connaitre la valeur du nombre premier ? Faites attention à cela ...